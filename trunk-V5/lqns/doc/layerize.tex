\C 
\C $Id$
\C 
\C $Log$
\C Revision 31.0  2005/01/02 02:30:29  greg
\C Bring all files up to revision 31.
\C
\C Revision 30.0  2003/11/12 18:56:52  greg
\C Bring all files up to revision 30.0
\C
\C Revision 29.0  2003/06/13 00:48:38  greg
\C bounce version number.
\C
\C Revision 1.4  1995/01/11 21:05:12  greg
\C Revised for R12 of MVA software.
\C
\C Revision 1.3  1994/12/09  02:02:36  greg
\C update.
\C
\C Revision 1.2  1994/08/04  20:52:11  greg
\C Intermediate save
\C
\C Revision 1.1  1994/06/24  19:11:32  greg
\C Initial revision
\C
\C
\C ----------------------------------------------------------------------
\section{Layerizer}
\label{sec:layerize}

This set of classes is used to create and solve submodels to arrive at
a global solution for a \link{\emph{``Stochastic Rendevous
    Network''}}[~\Cite]{srvn:woodside-89b} or \link{\emph{``Layered
    Queueing Model''}}[~\Cite]{perf:rolia-92}.  The basic solution
strategy is as follows:
\begin{enumerate}
\item The original model is broken up into a set set of submodels or
  \bold{partitions}.
\item Each submodel is solved using \link{Mean Value
    Analysis}{sec:mva}.
\item The residence times found from one submodel are then used to
  modify the service times for the others.
\end{enumerate}
Steps 2 and 3 are repeated until the desired convergence criteria are
met.

There are two different layer generation schemes defined:
\begin{enumerate}
\item \link{Hardware-Software partitioning}[ (\Sec\Ref)]{sec:hwsw},
  from \link{Rolia}[~\Cite]{perf:rolia-92}.
\item \link{Merged partitioning}[ (\Sec\Ref)]{sec:merged} (new).
\end{enumerate}

\subsection{Layerizer Class Hierarchy}
\label{sec:layerize-hierarchy}

The class relationships for the layer creation module are shown in
\htmlonly{the \link{figure
    below}{fig:layerize}}\texonly{Figure~\ref{fig:layerize}}.  The
classes \file{Layerize} and \file{HwSw_Layerize} are both abstract
superclasses which are not used directly.  The class \file{Interlock}
is used to augment the MVA solution with interlocking.  It's operation
is orthognal to layer creation, so if it's functionality is needed, it
is included and replaces the
\link{\code{interlock()}}{sec:layerize-interlock} function.

\begin{figure}[htbp]
  \label{fig:layerize}
  \begin{center}
    \T \tex \leavevmode \input{layerize.epic}
    \caption{Layerizer Class Hierarchy}
    \H \htmlimage{layerize.gif}
  \end{center}
\end{figure}

\htmlrule
\subsection{Class Layerize}

Users of this class create and solve models in three steps:
\begin{enumerate}
\item Call the appropriate constructor.
\item Call \link{\code{generate()}}{sec:layerize-generate}.
  \code{Generate()} calls
  \link{\code{extend()}}{sec:layerize-extend} to add extra stations
  to the basic model then calls
  \link{\code{initialize()}}{sec:layerize-initialize} to set up the
  station parameters.
\item Call \link{\code{solve()}}{sec:layerize-solve}.
\end{enumerate}
Results from the solution process are stored in the task and processor
entities. 

\subsubsection{Instance Variables}
\label{sec:layerize-ivars}

\begin{verbatim}
public:
    short valid;                /* 1 if model solution valid.   */

protected:
    Vector<Task *> * client;    /* Table of clients by level.   */
    Vector<Entity *> * server;  /* Table of servers by level.   */
    unsigned n_partitions;      /* Number of submodels.         */
    long coreCount;             /* Number of MVA iterations.    */
    long stepCount;             /* Number of Model iterations.  */
    unsigned maxDepth;          /* Maximum depth of this model. */

private:
    Vector <Task *> path;       /* Used for locating loops.     */
\end{verbatim}

\begin{description}
\item[client] \texonly{---} An array of vectors of pointers to
  tasks.  This array is used to create clients for each submodel.
  Processors can never act as clients.  Refer to subclasses for more
  information. 
\item[coreCount] \texonly{---} The number of iterations of the core
  MVA \link{\code{step()}}{sec:mva-step} function.
\item[maxDepth] \texonly{---} The number of levels in the model.
\item[n_partitions] \texonly{---} The number of submodels.  See
  classes \link{\code{HwSw_Layerize}}[ (\Sec\Ref)]{sec:hwsw} and
  \link{Merged_Layerize}[ (\Sec\Ref)]{sec:merged}
\item[path] \texonly{---} Current path being traced through
  \link{\code{findChildren()}}{sec:layerize-findChildren}. \\
\item[server] \texonly{---} An array of vectors of pointers to
  entities.  This array is used to create servers for each submodel
  and may contain both tasks and processors.  Refer to subclasses for
  more information.
\item[valid] \texonly{---} A boolean value which indicates whether the
  model solution was sucessful or not.
\end{description}

\subsubsection{Constructors for Layerize}
\label{sec:layerize-constructors}

Models are generated by calling the constructor for the desired type
of solution, e.g.:
\begin{itemize}
\item \link{Strict Layers,}{sec:hwsw-strict} \texonly{ (Section ~\ref{sec:hwsw-strict})}
\item \link{Loose Layers,}{sec:hwsw-loose} \texonly{ (Section ~\ref{sec:hwsw-loose})}
\item \link{Merged Layers,}{sec:merged} \texonly{ (Section ~\ref{sec:merged})}
\end{itemize}
or any of the above with \link{interlocking}{sec:interlock}.  

\begin{verbatim}
    Layerize();
\end{verbatim}

The class \file{Layerize} itself is an abstract superclass.

\subsubsection{Initialization}
\begin{description}

\label{sec:layerize-generate}
\item[generate] \texonly{---} Generate layers.\\
\code{void generate( Vector<Task *>& tasks, const unsigned n );}

Generate the model from the input data.  The alorithm is as follows:

\begin{example}
  for \var{aTask} in \var{tasks} do
    if \var{aTask} is a reference task then
      \link{\code{findChildren}}{sec:layerize-findChildren}(\var{aTask})
    end if
  end for
  \link{\code{addToLayer}}{sec:layerize-addToLayer}()   \{ Add tasks to layers. \}
  \link{\code{extend}}{sec:layerize-extend}()       \{ Extend the model. \}
  \link{\code{initialize}}{sec:layerize-initialize}()   \{ Final initialization. \}
\end{example}

The function \code{findChildren()} is used to walk the task graph by
following all calls made by \var{aTask}.  As it traverses the graph,
it sets the tasks's \link{\var{depth}}{sec:entity-ivars} based on the
depth of the task in the call graph.  \code{AddToLayer()} is called to
add each task (and possibly processor) in the model to either the
\var{client} or \var{server} or both data structures.  It must be
implemented by subclasses (See classes \link{\file{HwSw_Layerize}}[
(\Sec\Ref)]{sec:hwsw} and \link{\file{Merged_Layerize}}[(
\Sec\Ref)]{sec:merged}).  \code{Extend()} is used to add additional
entities to the model as needed; by default it performs no operation
(it is overriddenin \link{\file{HwSw_Layerize}}[
(\Sec\Ref)]{sec:hwsw}).  The function
\link{\code{initialize()}}{sec:layerize-initialize} is used to set the
initial waiting times, generate additional linkage information
required for model solution, and set up any other data structures.

\label{sec:layerize-findChildren}
\item[findChildren] \texonly{---} Locate Children.\\
\code{void findChildren(Task * parent, unsigned pathId, unsigned depth);}

Starting from \var{parent}, find all tasks that are called either
directly or indirectly.  \var{PathId} is used to locate loops in the
call chain --- loops are not permitted and result in exceptions.
\var{depth} is the current depth of the search.  The instance variable
\link{\var{maxDepth}}{sec:layerize-ivars} is modified to reflect the
maximum value of \var{depth}.  

\label{sec:layerize-addToLayer}
\item[addToLayer] \texonly{---} Add tasks to layers.\\
\code{void addToLayer();}

Add tasks to the various layers.  Implemented by subclasses.

\label{sec:layerize-extend}
\item[extend] \texonly{---} Extend model.\\
\code{unsigned extend( Vector<Task *>& tasks, const unsigned n );}

Extend the model by creating new entities.  Return the number of new
\bold{servers} created.  Implemented by subclasses.

\label{sec:layerize-initialize}
\item[initialize] \texonly{---} Initialize data structures.\\
\code{void initialize();}

The base-class implementation of \code{initialize()} sets up the calls
to the processor corresponding to each entry on every task by calling
\link{\code{configure()}}[ defined in class \file{Entry}, Section
\Ref]{sec:entry-configure}.  This functionality is extended by
subclasses to perform any other initialization.  Refer to:
\begin{itemize}
\item \link{\file{HwSw_Layerize}}[ (\Sec\Ref)]{sec:hwsw},
\item \link{\file{Merged_Layerize}}[( \Sec\Ref)]{sec:merged},
\item \link{\file{HwSw_Strict_Interlock_Layerize}}[( \Sec\Ref)]{sec:hwsw-strict-interlock},
\item \link{\file{HwSw_Loose_interlock_Layerize}}[( \Sec\Ref)]{sec:hwsw-loose-interlock} and
\item \link{\file{HwSw_Merged_Interlock_Layerize}}[( \Sec\Ref)]{sec:merged-interlock}).
\end{itemize}

\end{description}

\subsubsection{Queries}

\begin{description}

\item[partition] \texonly{---} Return partition number\\
\code{unsigned partition( const Entry * anEntry ) const;}

Return the \link{\bold{partition}}{sec:layerize} number for
\var{anEntry}.  The partition number is used as an index into
\link{\var{savedWait}}[ (\Sec\Ref)]{sec:entry-ivars}. This
function is implemented by subclasses.  See:
\begin{itemize}
\item Class \link{\file{HwSw_Layerize}}[ (\Sec\Ref)]{sec:hwsw-partition}
\item Class \link{\file{Merged_Layerize}}[ (\Sec\Ref)]{sec:merged-partition}
\end{itemize}
\end{description}

\subsubsection{Computation}

\begin{description}

\label{sec:layerize-interlock}
\item[interlock] \texonly{---} Interlocking Calculation\\
\code{void interlock( Task& aTask, const unsigned nClasses ) const;}

Set the interlocked throughput component for \var{aTask}.  The
interlocked throughput is used to adjust the queue length at the
station corresponding to \var{aTask}.  By default, there is no
interlocked throughput.  Subclasses override the default by inheriting
the \code{interlock()} function from Class \link{\file{Interlock}}[
(\Sec\Ref)]{sec:interlock}.

\label{sec:layerize-solve}

\item[solve] \texonly{---} Solve model.\\
\code{SolverReport solve();}

Implemented by subclasses.

\begin{itemize}
\item \link{Strict Layers}{sec:hwsw} of
  \link{Rolia}[~\Cite]{perf:rolia-92}.
\item \link{Loose Layers}{sec:hwsw-loose}.
\item Strict Layers with \link{interlocking}{sec:hwsw-strict-interlock}.
\item \link{Merged Partion Layers}{sec:merged}
\end{itemize}

\label{sec:layerize-solveLayer}
\item[solveLayer] \texonly{---} Solve a layer and return difference with last solution.\\
\code{solveLayer( ( const unsigned n_clients, Vector<Task *>& clients,
  const unsigned n_servers, Vector<Entity *>& servers, const unsigned
  classType, const unsigned waitType );} 

\code{SolveLayer()} creates a model for the \link{MVA}{sec:mva}
solver, solves it, then stores the results back in the original
\link{\bold{task}}{sec:task} and
\link{\bold{processor}}{sec:processor} data structures.  The algorithm
is shown below.

\begin{example}
  \var{i} = 1           \{ Station index \}

  \{ Make Stations \}

  for \var{aClient} in \var{clients} do
    \var{station}[\var{i}] = \link{\code{makeClient}}{sec:task-makeClient}(\var{aClient})
    \var{i} = \var{i} + 1
  end for
  for \var{aServer} in \var{servers} do
    \var{station}[\var{i}] = \link{\code{makeServer}}{sec:entity-makeServer}(\var{aServer})
    \var{i} = \var{i} + 1
  end for

  \{ Solve Model \}

  \link{\code{solve}}{sec:mva-solve}(\var{station})

  \{ Save Results \}

  for \var{aClient} in \var{clients} do
    \link{\code{saveClientResults}}{sec:task-saveClientResults}(\var{aClient})
  end for
  for \var{aServer} in \var{servers} do
    \link{\code{saveServerResults}}{sec:entity-saveServerResults}(\var{aServer})
  end for
\end{example}

The first section of the agorithm creates the MVA model.  The
functions \link{\code{makeClient}}[ (\Sec\Ref)]{sec:task-makeClient}
and \link{\code{makeServer}}[ (\Sec\Ref)]{sec:entity-makeServer} are
used to create the appropriate server type (e.g., delay, FCFS,...),
and set the \bold{service time} and \bold{visit ratios}.  The service
time for a task or processor acting as a server in the MVA model is
the sum of the residence times to each of the entities that it calls.
The service time for a client is the sum of the residence times to all
entities in all submodels except for the submodel identified by
\var{partition}.  Each client is represented as a separate
\bold{class} in the MVA model.  The \bold{think time} assigned to each
class is set to the idle time of the corresponding client entity.

The second section of the algorthim calls the MVA solver to solve the
MVA model.

The final section of the algorithm saves the throughput at each entry
for all clients and servers and the waiting time between each client
and server.  The waiting times to all entities in the submodel
specified by \var{partition} are then summed for use in subsequent
calls to \code{solveLayer()}.  For more information, refer to
\link{\code{saveServerResults()}}[
(\Sec\Ref)]{sec:entity-saveServerResults},
\link{\code{saveClientResults()}}[
(\Sec\Ref)]{sec:task-saveClientResults} and \link{\code{deltaWait()}}[
(\Sec\Ref)]{sec:entry-deltaWait}.

\code{SolveLayer()} returns the largest difference in waiting times
between iterations.

\end{description}


\subsubsection{Input and Output}
\begin{description}
\item[print] \texonly{---} Print layers \\
\code{ostream& print( ostream& os ) const;}

This function is used to debug the solver and is invoked whenever the
\bold{-d} flag is specified.

\end{description}

\htmlrule
\subsection{Class HwSw_Layerize}
\label{sec:hwsw}

The class \file{HwSw_Layerize} itself is an abstract superclass for
solving models using the ``Method of Layers'' solution strategy.
Models are split into \link{two separate submodels}[
(Figure~\Ref)]{fig:hwsw-layering} or \bold{partitions}, one modeling
the contention delays between software tasks, and the second modeling
contention for hardware devices.  The solution proceeds by iterating
between the hardware and software submodels, using the member
functions \link{\code{solveHardware()}}{sec:hwsw-solveHardware} and
\link{\code{solveSoftware()}}{sec:hwsw-solveSoftware} respectively,
until the convergence criteria is met.

\begin{figure}[p]
  \label{fig:hwsw-layering}
  \begin{center}
    \T \tex \leavevmode \input{hwsw-layering.epic}
    \caption{Hardware-Software Layering strategy}
    \H \htmlimage{hwsw-layering.gif}
  \end{center}
\end{figure}

As shown in the figure, the software model can also consist of a
number of layers.  The solver creates submodels consisting of adjacent
layers which are solved iteratively to convergence.

The subclasses of \file{HwSw_Layerize} supply the member function
\link{\code{solveSoftware()}}{sec:hwsw-solveSoftware}.  These classes are:
\begin{itemize}
\item \link{\file{HwSw_Strict_Layerize}}{sec:hwsw-strict},
\item \link{\file{HwSw_Strict_Interlock_Layerize}}{sec:hwsw-strict-interlock},
\item \link{\file{HwSw_Loose_Layerize}}{sec:hwsw-loose}, and
\item \link{\file{HwSw_Loose_Interlock_Layerize}}{sec:hwsw-loose-interlock}.
\end{itemize}
The differences arrise from the method used to solve breaches in the
strict layering, and for interlocking effects.

Refer to \link{\code{generate()}}[ (\Sec\Ref)]{sec:layerize-generate}
for model construction, and to \link{\code{solve()}}[
(\Sec\Ref)]{sec:layerize-solve} for model solution.  This class
implements \code{addToLayer()} and \code{extend()} to add
Flow-Equivalent Service Centers to the model.

\subsubsection{Instance Variables}
\begin{verbatim}
    Vector <Task *> fesc_task;  /* A collection of FESC.        */
\end{verbatim}

In addition to \var{fesc_task}, \file{HwSw_Layerize} also
treats \var{client} and \var{server} specially.

\begin{description}
\item[client] \texonly{---} An array of vectors of pointers to tasks.
  These tasks are \emph{clients} in a two-level model and
  \emph{always} call a server.  Tasks that make no calls to other
  tasks are not placed in this array.  Tasks which are both clients
  and servers are placed in \emph{both} this array and the
  \var{client} array.  The array is dimensioned by \var{maxDepth} and
  is indexed from 1 to n.
\item[fesc_task] \texonly{---} An array of vectors of pointers to
  tasks.  These tasks are flow equivalent service centers that have
  been added to the model through the call to \code{extend()}.
\item[server] \texonly{---} An array of vectors of pointers to
  entities.  Entities can be either \link{tasks}{sec:task} or
  \link{processors}{sec:processor}.  Servers need not make any calls.
  All tasks in the model should be found in this data structure.
  Tasks which are both clients and servers are placed in \emph{both}
  this array and the \var{client} array.  The array is dimensioned by
  \var{maxDepth} and is indexed from 1 to n.
\end{description}

\subsubsection{Constructors for HwSw_Layerize}

Abstract Superclass.

\begin{verbatim}
    HwSw_Layerize() : Layerize() {}
\end{verbatim}

\subsubsection{Initialization}
\begin{description}

\label{sec:hwsw-layerize-extend}
\item[extend] \texonly{---} Extend model.\\
\code{unsigned extend( Vector<Task *>&, const unsigned );}

Extend the model with flow equivalent service centers.  Return the
number of new servers created.  Overrides
\link{superclass}{sec:layerize-extend}.

\item[initialize] \texonly{---} Initialize data structures.\\
\code{void initialize();}

Initialize residence times assuming no contention.

\label{sec:hwsw-strict-fesc}
\item[makeFESCServer] \texonly{---} Create a FESC Server.\\
\code{void makeFESCServer( const Task& fromTask, Call& toEntry );}

Create and connect a flow equivalent service center task to span the
layers between \var{fromTask} and \var{toEntry}. 

\end{description}

\subsubsection{Queries}

\begin{description}

\label{sec:hwsw-partition}
\item[partition] \texonly{---} Return partition number\\
\code{unsigned partition( const Entry * anEntry ) const;}

Return the partition number.  For this class and its
descendents, there are two partitions: \strong{R_DEVICE} corresponding to
the hardware submodel and \strong{R_GROUP} corresponding to the task
model. 

\end{description}


\subsubsection{Computation}

\begin{description}

\item[solve] \texonly{---} Solve Model.\\
\code{SolverReport solve();}

Solve the model starting from the top and working down.  Return the
number of inner loop iterations.

\label{sec:hwsw-solveHardware}
\item[solveHardware] \texonly{---} Solve Hardware submodel.\\
\code{double solveHardware();}

Generate and solve the hardware submodel.  The algorithm is very simple:
\begin{example}
  \link{\code{solveLayer}}{sec:layerize-solveLayer}(\var{task},\var{processor},\strong{R_DEVICE})
\end{example}

Note that the arguments \var{task} and \var{processor} correspond to
all tasks and all processors in the original model.

\label{sec:hwsw-solveSoftware}
\item[solveSoftware] \texonly{---} Solve Software submodel.\\
\code{double solveSoftware()}

Solve the software model.  Abstract superclass.  Implemented in:
\begin{itemize}
\item \link{\code{HwSw_Strict_Layerize}}{sec:hwsw-strict-solveSoftware}
\item \link{\code{HwSw_Loose_Layerize}}{sec:hwsw-loose-solveSoftware}
\end{itemize}
\end{description}


\htmlrule
\subsection{Class HwSw_Strict_Layerize}
\label{sec:hwsw-strict}

This class solves the software contention model a complete layer at a
time, i.e., all tasks in layer 1 \texonly{in
  Figure~\ref{fig:hwsw-layering}} are \bold{clients} and all tasks in
layer 2 are \bold{servers} \link{(cf. loose layers}[ in
Section~\Ref]{sec:hwsw-loose}).  The model assumes that tasks in layer
\math{i} only call tasks in layer {i+1}.  If this assumption is
violated, then \dfn{Flow Equivalent Server Centers} are created at the
intermediate levels to restore the strict layering.

\subsubsection{Constructors for HwSw_Strict_Layerize}

The constructor for \file{HwSw_Strict_Layerize} takes no arguments.

\begin{verbatim}
    HwSw_Strict_Layerize() : HwSw_Layerize()
\end{verbatim}

\subsubsection{Computation}
\begin{description}

\label{sec:hwsw-strict-solveSoftware}
\item[solveSoftware] \texonly{---} Solve software submodel \\
\code{double solveSoftware();}

\code{SolveSoftware()} selects two adjacent layers from the software
model, beginning from the top, and calls
\link{\code{solveLayer()}}{sec:layerize-solveLayer}.  The algorithm is
shown below:

\begin{example}
  \var{i} = 1
  while \var{i} < \var{maxDepth} do
    \link{\code{solveLayer}}{sec:layerize-solveLayer}(\var{client}[\var{i}],\var{server}[\var{i}+1],\strong{R_GROUP})
    \var{i} = \var{i} + 1
  end while
\end{example}

Each loop of the algorithm updates the value of
\link{\var{savedWait}}[ (\Sec\Ref)]{sec:entry-ivars} for the partition
\strong{R_GROUP} for the level \var{i} (i.e., from the top of
\htmlonly{\link{the figure}}{fig:hwsw-layering}
\texonly{Figure~\ref{fig:hwsw-layering}} down).

\code{SolveSoftware()} returns the largest difference in waiting time
found by \code{solveLayer()}.

\end{description}

\htmlrule
\subsection{Class HwSw_Loose_Layerize}
\label{sec:hwsw-loose}

Loose Layers.  This scheme is much like the method used by
\link{Woodside}[~\Cite]{srvn:woodside-89b}.  Not implemented.  

\subsubsection{Computation}
\begin{description}

\label{sec:hwsw-loose-solveSoftware}
\item[solveSoftware] \texonly{---} Solve software submodel \\
\code{double solveSoftware();}

\end{description}

\htmlrule
\subsection{Class HwSw_Strict_Interlock_Layerize}
\label{sec:hwsw-strict-interlock}

interlocker...

\htmlrule
\subsection{Class HwSw_Loose_Interlock_Layerize}
\label{sec:hwsw-loose-interlock}

interlocker...

\htmlrule
\subsection{Class Merged_Layerize}
\label{sec:merged}

The class \file{Merged_Layerize} implements a different form of
layering which merges the hardware and software contention models
together into \link{one model}[ (Figure~\Ref)]{fig:merged-layering}.

\begin{figure}[htp]
  \label{fig:merged-layering}
  \begin{center}
    \T \tex \leavevmode \input{merged-layering.epic}
    \caption{Merged Layering strategy}
    \H \htmlimage{merged-layering.gif}
  \end{center}
\end{figure}

Submodel construction begins from the bottom up and is based on the
\bold{servers} at a given layer (\link{cf. Class
  \file{HwSw_Layerize}}{sec:hwsw}).  The following steps are
performed:
\begin{enumerate}
\item The layer number for a particular server is found using the
  intermediate \link{\code{findChildren()}}[
  (\Sec\Ref)]{sec:layerize-findChildren}.
\item All tasks and processors are inserted into the \var{server}
  array in \link{\code{addToLayer()}}[(
  \Sec\Ref)]{sec:merged-addToLayer}.
\item All callers to a given server at level \math{l} are inserted
  into the \var{client} array at level \math{l-1}.  This index does
  not necessarily correspond to the layer in which the task actually
  resides.  Furthermore, clients may appear in more than one layer in
  the \var{client} array, although thay may appear no more than once
  at a given layer.
\end{enumerate}
The submodels are solved by picking clients and servers from adjacent
levels and calling
\link{\code{solveLayer()}}[ (\Sec\Ref)]{sec:layerize-solveLayer}.  

The \bold{partition number} (or submodel) passed to
\link{\code{solveLayer()}}{sec:layerize-solveLayer} corresponds to the
actual client layer being solved.  When setting up the MVA model, the
service times for clients do not include the residence times for the
corresponding partition number.  After the MVA model has been solved,
these times are updated and used for all of the other submodels.

\subsubsection{Constructors for Layerize}

The constructor for \file{Merged_Layerize} takes no arguments.  

\begin{verbatim}
    Merged_Layerize() : Layerize() {}
\end{verbatim}

\subsubsection{Initialization}

\begin{description}
\label{sec:merged-addToLayer}
\item[addToLayer] \texonly{---} Add Entities to layers.\\
\code{void addToLayer();}

Insert all tasks and processors at their designated layer into the
\var{server} array.  The \var{client} array is set up in
\code{initialize()}. 

\label{sec:merged-initialize}
\item[initialize] \texonly{---} Initialize data structures. \\
\code{void initialize();}

First, set up all reverse links from one entry to another through
\link{\code{configure()}}[ \Sec\Ref]{sec:entry-configure}.  Next,
Initialize residence times assuming no contention using
\link{\code{initWait()}}[ \Sec\Ref]{sec:entry-initWait}.  Finally,
locate all callers to a given task and insert into the \var{client}
array.

\end{description}

\subsubsection{Queries}

\begin{description}

\label{sec:merged-partition}
\item[partition] \texonly{---} Return partition number\\
\code{unsigned partition( const Entry * anEntry ) const;}

The partition (or submodel) number corresponds to the client level in
this model (cf. \link{\code{partition()}}[
  \Sec\Ref]{sec:hwsw-partition}).

\end{description}

\subsubsection{Computation}

\begin{description}

\item[solve] \texonly{---} Solve the model\\
\code{SolverReport solve();}

\code{SolveSoftware()} selects two adjacent layers from the model,
beginning from the top, and calls
\link{\code{solveLayer()}}{sec:layerize-solveLayer}.  The algorithm is
shown below:

\begin{example}
  repeat
    \var{i} = 1
    while \var{i} <= \var{maxDepth} do
      \link{\code{solveLayer}}{sec:layerize-solveLayer}(\var{client}[\var{i}],\var{server}[\var{i}+1],\var{i})
      \var{i} = \var{i} + 1
    end while
  until convergence
\end{example}

Each loop of the algorithm updates the value of
\link{\var{savedWait}}[ (\Sec\Ref)]{sec:entry-ivars} for the partition
\var{i}.  

This algorithm is almost identical to that for
\link{\code{solveSoftware()}}[
(\Sec\Ref)]{sec:hwsw-strict-solveSoftware} in class
\file{HwSw_Strict_Layerize} except that the partition number is
\var{i} instead of \strong{R_GROUP} and that there is one more
iteration of the inner loop to account for the addition of processors
to the model.

\code{Solve()} returns the largest difference in waiting time found by
\code{solveLayer()}.

\end{description}

\subsubsection{Input and Output}

\begin{description}
\item[print] \texonly{---} Print layers\\
\code{ostream& print( ostream& ) const;}

This function is used to debug the solver and is invoked whenever the
\bold{-d} flag is specified.

\end{description}

\htmlrule
\subsection{Class Merged_Interlock_Layerize}
\label{sec:merged-interlock}

\htmlrule
\subsection{Class Interlock}
\label{sec:interlock}

\subsubsection{Instance Variables}
\label{sec: -ivars}
\begin{verbatim}
private:
    Chain * chainTable;
\end{verbatim}

\begin{description}
\label{sec:interlock-interlock}
\item[chainTable] \texonly{---} Table for storing throughput chains.
\end{description}

\subsubsection{Constructors for Interlock}

\begin{verbatim}
    Interlock() {};
\end{verbatim}

\subsubsection{Initialization}
\begin{description}
\item[initialize] \texonly{---} Initialize the chain table.\\
\code{void initialize();}

Allocate a \var{chainTable} and initialize it.

\end{description}

\subsubsection{Computation}

\begin{description}
\item[interlock] \texonly{---} Set interlocked throughput \\
\code{void interlock( Task&, const unsigned ) const;}

Set the interlocked throughput for all calling \bold{classes} of
\var{aTask}.  This function is meant to override
\link{\code{interlock()}}[ defined in class
\file{Layerize}]{sec:layerize-interlock}.  It calls
\link{\code{findInterlock()}}[ defined in class \file{Chain}]{sec:chain-findInterlock}.

\end{description}

\subsubsection{Input and Output}
\begin{description}
\item[print] \texonly{---} Print out chain table\\
\code{ostream& print( ostream& ) const;}

\end{description}
\C Local Variables: 
\C mode: latex
\C TeX-master: "lqns"
\C End: 
